---
title: "Tutorial"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Tutorial}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(ECCCM)
```

## Introduction 

The following tutorial is aimed to explain the use of the `ECCCM` package, most of the functions presented here have additional help available using `?function`. The aim of the package is to conduct inference on SNPs using a reference panel $G_r$. The model assumed is 

$$ y_o = G_o \beta + \epsilon, \quad \epsilon \sim N(0, \sigma^2). $$


The assumption is that only marginal coefficient are reported $\frac{1}{n_o}G_o' y$ . 

### Data generation 

We will create data according to the model, org or o will refer to the original study. For the purpose of the example, $n_{o} = 5000,n_{r} = 1000, p = 15, \Sigma_{i,j} = 0.8^{|i - j|}, h = 0.05$, where $h$ is the explained variance (that is $\sigma = 1 - h$ for scaled $y$).  There will be two causal SNPs at locations $1, 15$, and the Minor Allele Frequency (MAF) is generated by $p = max(Beta(2, 5) / 3, 0.05)$ (the max is element-wise), to ensure that the SNPs are not empty.  
We assume that all of the data is standardized. 

```{r}
set.seed(995)
#### Parameters 
n.org   <- 5000 
n.ref   <- 1000 
snp.num <- 15 
rho     <- 0.95
h       <- 0.1
beta.vec <- rep(0, snp.num) 
beta.vec[c(1, 15)] <- 1 

cov.mat <- rho^abs(outer(1:snp.num, 1:snp.num, '-'))
X.org   <- MASS::mvrnorm(n.org, rep(0, snp.num), cov.mat) 
X.ref   <- MASS::mvrnorm(n.ref, rep(0, snp.num), cov.mat)
### Transforming to gene 
maf.vec <- pmax(rbeta(snp.num, 2, 5) / 3, 0.05) ## MAF 
#### Create SNPs transforms normal vector into 0,1,2 while keeping MAF
snpMaker <- function(x.vec, maf) {
  g.vec <- x.vec
  g.vec[x.vec <= qnorm(1 - maf)] <- 0
  g.vec[x.vec >  qnorm(1 - maf)]  <- 1
  g.vec[x.vec >  qnorm(1 - (1 / 3) * maf)]  <- 2
  return(g.vec)
}

G.org  <- scale(sweep(X.org, 2, maf.vec, snpMaker))
G.ref  <- scale(sweep(X.ref, 2, maf.vec, snpMaker))

### Creating model 
true.y           <- drop(G.org %*% beta.vec)
unexplain.var    <- (1 - h) / h
y                <- scale(true.y + rnorm(n.org, mean = 0, sd = sqrt(unexplain.var)))


### Reported 
beta.report <- n.org^(-1) * t(G.org) %*% y 

```

### Estimating variance of coefficients estimate 

The natural estimator of $\beta$ is  

$$\hat{\beta}_{mc} = \frac{n_r}{n_o} (G_r'G_r)^{-1}G_o' y.$$
The naive variance estimator of this estimate is $\frac{\hat{\sigma}^2}{n_o}\hat{\Sigma}_r$. We will can use `ECCCM::marginalToJoint` to transform the marginal association into multivariate associations. 

```{r}
# Transform coefficients from marginal to multivariate 
marg.to.joint <- marginalToJoint(marg.beta.hat = beta.report,
                                 cor.r = cor(G.ref),
                                 n.o = n.org,
                                 sigma = 1)
```

To test the coefficients we can use the function `ECCCM::testCoef`, which conduct a two sided normal test. 

```{r}
test.df <- testCoef(est.beta = marg.to.joint$est.beta.hat,
                    var.beta = marg.to.joint$naive.var.beta.hat,
                    method = 'BH')


which(test.df[ ,4] < 0.05)
```

After correction for multiplicity, we obtain 5 significant SNPs at locations `1, 3, 6, 8 and 15`, implying an FDR of $0.6$. We need to adjust for the variance added from using the reference panel. 

The asymptotic distribution of $\hat{\beta}_{mc}$ is 

$$\lim_{n_r,n_o \rightarrow \infty} \sqrt{n_r}  (\hat{\beta}_{mc} - \beta) \sim N_p(0,  c\sigma^2 R^{-1} +  (1 + c)(\beta' \otimes R^{-1}) \boldsymbol{V}_R (\beta \otimes R^{-1})),$$
where $c=\frac{n_r}{n_o}$, and $\boldsymbol{V}_R$ is the variance of the correlation matrix. To estimate this additional variance we can use the function `ECCCM::analyzeRef`. 
We filter the coefficients using a BH adjustment at level 0.05, and estimate the $\sigma$. 

```{r}
variance_adjusted <- analyzeRef(marg.beta.hat = beta.report,
                                x.r           = G.ref,
                                n.o           = nrow(G.org),
                                method.filter = 'BH',
                                sigma.method  = 'estimate',
                                qu            = 0.05)

which(variance_adjusted$test.correct$pval.adjusted.BH < 0.05)
```

Only the two causal SNPs are found to be significant. 



